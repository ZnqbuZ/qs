Index: src/main.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>mod gateway;\r\n\r\nuse anyhow::Result;\r\nuse bytes::{Bytes, BytesMut};\r\nuse std::net::SocketAddr;\r\nuse std::sync::Arc;\r\nuse std::thread::sleep;\r\nuse std::time::{Duration, Instant};\r\nuse tokio::io::{AsyncReadExt, AsyncWriteExt};\r\nuse tokio::sync::oneshot;\r\nuse tracing::{error, info, trace};\r\nuse tracing_subscriber::EnvFilter;\r\n// 假设你的库名为 my_quic_lib\r\n// use my_quic_lib::gateway::quic::{QuicEndpoint, QuicPacketMargins, QuicCtrl, QuicPacket};\r\n// 这里使用你提供的代码中的路径，你需要根据实际情况调整 use 路径\r\n\r\n// --- 模拟网络转发层 ---\r\n// 它的作用是把 Server 出去的包塞给 Client 的输入，反之亦然。\r\n// 这样完全跳过了 UDP Socket 系统调用，只测试逻辑性能。\r\nasync fn run_virtual_network(\r\n    mut server_pkt_rx: crate::gateway::quic::QuicPacketRx,\r\n    server_ctrl: Arc<crate::gateway::quic::QuicCtrl>,\r\n    mut client_pkt_rx: crate::gateway::quic::QuicPacketRx,\r\n    client_ctrl: Arc<crate::gateway::quic::QuicCtrl>,\r\n    client_addr: SocketAddr,\r\n    server_addr: SocketAddr,\r\n) {\r\n    let s2c = tokio::spawn(async move {\r\n        while let Some(mut pkt) = server_pkt_rx.recv().await {\r\n            // 在真实网络中，IP头会被剥离，这里我们模拟接收端看到的“对端地址”\r\n            // Server 发给 Client，Client 收到时看到的是 Server 的地址\r\n            pkt.addr = server_addr;\r\n            if let Err(e) = client_ctrl.send(pkt).await {\r\n                error!(\"Virtual network: failed to forward packet from server to client: {}\", e);\r\n                break;\r\n            }\r\n        }\r\n    });\r\n\r\n    let c2s = tokio::spawn(async move {\r\n        while let Some(mut pkt) = client_pkt_rx.recv().await {\r\n            // Client 发给 Server，Server 收到时看到的是 Client 的地址\r\n            pkt.addr = client_addr;\r\n            if let Err(e) = server_ctrl.send(pkt).await {\r\n                error!(\"Virtual network: failed to forward packet from client to server: {}\", e);\r\n                break;\r\n            }\r\n        }\r\n    });\r\n\r\n    // 等待任意一方断开\r\n    let _ = tokio::select! {\r\n        _ = s2c => {},\r\n        _ = c2s => {},\r\n    };\r\n}\r\n\r\n// --- 基础环境搭建 ---\r\nstruct TestEnv {\r\n    server: crate::gateway::quic::QuicEndpoint,\r\n    client: crate::gateway::quic::QuicEndpoint,\r\n    server_ctrl: Arc<crate::gateway::quic::QuicCtrl>,\r\n    client_ctrl: Arc<crate::gateway::quic::QuicCtrl>,\r\n    server_stream_rx: crate::gateway::quic::QuicStreamRx,\r\n    _network_handle: tokio::task::JoinHandle<()>,\r\n}\r\n\r\nasync fn setup_env() -> TestEnv {\r\n    let server_addr: SocketAddr = \"127.0.0.1:5000\".parse().unwrap();\r\n    let client_addr: SocketAddr = \"127.0.0.1:6000\".parse().unwrap();\r\n    let margins = crate::gateway::quic::QuicPacketMargins { header: 0, trailer: 0 };\r\n\r\n    // 1. 启动 Server\r\n    let mut server = crate::gateway::quic::QuicEndpoint::new();\r\n    let (server_pkt_rx, server_stream_rx) = server.run(margins).unwrap();\r\n    let server_ctrl = server.ctrl().unwrap();\r\n\r\n    // 2. 启动 Client\r\n    let mut client = crate::gateway::quic::QuicEndpoint::new();\r\n    let (client_pkt_rx, _client_stream_rx) = client.run(margins).unwrap();\r\n    _client_stream_rx.switch().set(false);\r\n    let client_ctrl = client.ctrl().unwrap();\r\n\r\n    // 3. 启动虚拟网络\r\n    let s_ctrl_clone = server_ctrl.clone();\r\n    let c_ctrl_clone = client_ctrl.clone();\r\n    let net_handle = tokio::spawn(async move {\r\n        run_virtual_network(server_pkt_rx, s_ctrl_clone, client_pkt_rx, c_ctrl_clone, client_addr, server_addr).await;\r\n    });\r\n\r\n    TestEnv {\r\n        server,\r\n        client,\r\n        server_ctrl,\r\n        client_ctrl,\r\n        server_stream_rx,\r\n        _network_handle: net_handle,\r\n    }\r\n}\r\n\r\n// --- 测试场景 1: 最大吞吐量 (Bulk Transfer) ---\r\nasync fn bench_throughput(total_size_mb: usize) {\r\n    trace!(\"=== 开始测试: 吞吐量 ({} MB) ===\", total_size_mb);\r\n    let mut env = setup_env().await;\r\n    let server_addr: SocketAddr = \"127.0.0.1:5000\".parse().unwrap();\r\n\r\n    let payload_size = 1024 * 32; // 32KB chunks\r\n    let total_bytes = total_size_mb * 1024 * 1024;\r\n    let chunk_count = total_bytes / payload_size;\r\n\r\n    let data_chunk = Bytes::from(vec![0u8; payload_size]);\r\n\r\n    // Server 端接收并统计\r\n    let server_task = tokio::spawn(async move {\r\n        // 接收第一个流\r\n        if let Some(mut stream) = env.server_stream_rx.recv().await {\r\n            info!(\"Received stream from client\");\r\n            stream.ready().await.expect(\"Server stream ready failed\");\r\n            let mut buf = vec![0u8; 65535];\r\n            let mut received = 0;\r\n            while let Ok(n) = stream.read(&mut buf).await {\r\n                if n == 0 { break; }\r\n                received += n;\r\n                trace!(\"Received {} bytes\", received);\r\n            }\r\n            return received;\r\n        }\r\n        0\r\n    });\r\n\r\n    // Client 端发送\r\n    let start = Instant::now();\r\n    let mut client_stream = match env.client_ctrl.connect(server_addr, None, true).await {\r\n        Ok(s) => s,\r\n        Err(_) => {\r\n            // 连接指令已发出，Driver 正在后台进行 QUIC 握手\r\n            // 稍等片刻让 Transport Parameters 交换完成\r\n            tokio::time::sleep(Duration::from_millis(100)).await;\r\n            // 第二次尝试：此时应该已经 Connected 且有了 Stream Credit\r\n            env.client_ctrl.connect(server_addr, None, true).await.expect(\"Retry connect failed\")\r\n        }\r\n    };\r\n\r\n    for _ in 0..chunk_count {\r\n        client_stream.write_all(&data_chunk).await.expect(\"Write failed\");\r\n        trace!(\"Sent {} bytes\", payload_size);\r\n    }\r\n    client_stream.shutdown().await.expect(\"Shutdown failed\"); // 发送 FIN\r\n\r\n    let received_bytes = server_task.await.unwrap();\r\n    let duration = start.elapsed();\r\n\r\n    let mb_per_sec = (received_bytes as f64 / 1024.0 / 1024.0) / duration.as_secs_f64();\r\n    println!(\"完成。耗时: {:?}, 接收: {} MB\", duration, received_bytes / 1024 / 1024);\r\n    println!(\"带宽: {:.2} MB/s {:.2} Gbps (注意：这是纯内存拷贝+协议开销)\", mb_per_sec, mb_per_sec * 8.0 / 1024.0);\r\n}\r\n\r\n// --- 测试场景 2: 小包每秒处理能力 (PPS / Latency) ---\r\nasync fn bench_pps(iterations: usize) {\r\n    println!(\"=== 开始测试: PPS/Ping-Pong ({} 次) ===\", iterations);\r\n    let mut env = setup_env().await;\r\n    let server_addr: SocketAddr = \"127.0.0.1:5000\".parse().unwrap();\r\n\r\n    // Server 端: Echo Server\r\n    tokio::spawn(async move {\r\n        while let Some(mut stream) = env.server_stream_rx.recv().await {\r\n            tokio::spawn(async move {\r\n                stream.ready().await.unwrap();\r\n                let mut buf = [0u8; 1024];\r\n                loop {\r\n                    match stream.read(&mut buf).await {\r\n                        Ok(0) => break, // EOF\r\n                        Ok(n) => {\r\n                            // 收到数据立即回写\r\n                            if let Err(_) = stream.write_all(&buf[..n]).await { break; }\r\n                        }\r\n                        Err(_) => break,\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    });\r\n\r\n    // Client 端: 发送 Ping 等待 Pong\r\n    let mut client_stream = env.client_ctrl.connect(server_addr, None, true).await.expect(\"Connect failed\");\r\n    let ping_data = Bytes::from_static(b\"ping\");\r\n    let mut buf = [0u8; 1024];\r\n\r\n    let start = Instant::now();\r\n    for _ in 0..iterations {\r\n        client_stream.write_all(&ping_data).await.unwrap();\r\n        // 等待回复（同步阻塞式模拟 ping-pong）\r\n        let _ = client_stream.read(&mut buf).await.unwrap();\r\n    }\r\n    let duration = start.elapsed();\r\n\r\n    let pps = iterations as f64 / duration.as_secs_f64();\r\n    let avg_latency = duration.as_secs_f64() * 1000.0 * 1000.0 / iterations as f64; // microseconds\r\n\r\n    println!(\"完成。耗时: {:?}\", duration);\r\n    println!(\"PPS: {:.0} msgs/s\", pps);\r\n    println!(\"平均往返延迟 (RTT): {:.2} us\", avg_latency);\r\n}\r\n\r\n// --- 测试场景 3: 大量并发连接 (Concurrency) ---\r\nasync fn bench_concurrency(conn_count: usize) {\r\n    println!(\"=== 开始测试: 并发连接数 ({} 连接) ===\", conn_count);\r\n    let mut env = setup_env().await;\r\n    let server_addr: SocketAddr = \"127.0.0.1:5000\".parse().unwrap();\r\n\r\n    // Server 只要不断接受连接即可\r\n    tokio::spawn(async move {\r\n        let mut count = 0;\r\n        while let Some(mut stream) = env.server_stream_rx.recv().await {\r\n            stream.ready().await.unwrap();\r\n            count += 1;\r\n            if count >= conn_count {\r\n                break; // 只要连接建立成功即可\r\n            }\r\n        }\r\n    });\r\n\r\n    let start = Instant::now();\r\n    let mut set = tokio::task::JoinSet::new();\r\n\r\n    // 并发发起连接\r\n    // 注意：QuicDriver 是单线程处理所有连接的，这里的并发主要测试 channel 和 driver 的处理能力\r\n    for i in 0..conn_count {\r\n        let ctrl = env.client_ctrl.clone();\r\n        // 模拟不同的源端口，否则 quinn 可能会认为是同一个连接迁移\r\n        // 在我们上面的 virtual_network 里比较简单粗暴，真实情况需要更复杂的模拟\r\n        // 由于我们的 virtual_network 强制修改了 addr，这里其实是在模拟复用同一个 connection 创建 stream\r\n        // 如果要测试 *Connection* 数量，我们需要在 Client 端创建多个 Endpoint，或者修改 virtual_network 支持根据 stream ID 路由（这比较复杂）。\r\n        // 鉴于 quic/driver.rs 的实现，我们这里测试的是 *Stream* 的并发开启能力更为直接。\r\n\r\n        set.spawn(async move {\r\n            let _ = ctrl.connect(server_addr, Some(Bytes::from(format!(\"init data {}\", i))), true).await;\r\n        });\r\n    }\r\n\r\n    while let Some(_) = set.join_next().await {}\r\n\r\n    let duration = start.elapsed();\r\n    println!(\"完成。耗时: {:?}\", duration);\r\n    println!(\"连接/流建立速率: {:.0} /s\", conn_count as f64 / duration.as_secs_f64());\r\n}\r\n\r\n// --- 测试场景 4: 多流聚合带宽 (Aggregated Throughput) ---\r\nasync fn bench_aggregated_throughput(total_size_mb: usize, stream_count: usize) {\r\n    info!(\"=== 开始测试: 多流聚合带宽 (总量: {} MB, 并发流数: {}) ===\", total_size_mb, stream_count);\r\n    let mut env = setup_env().await;\r\n    let server_addr: SocketAddr = \"127.0.0.1:5000\".parse().unwrap();\r\n\r\n    let total_bytes = total_size_mb * 1024 * 1024;\r\n    // 确保总字节数能被流数量整除，方便计算\r\n    let bytes_per_stream = total_bytes / stream_count;\r\n    let payload_size = 32 * 1024; // 32KB chunks\r\n\r\n    // Server 端: 启动聚合接收任务\r\n    // 必须将 server_stream_rx 移动进去\r\n    let server_task = tokio::spawn(async move {\r\n        let mut join_set = tokio::task::JoinSet::new();\r\n        let mut total_received = 0;\r\n\r\n        // 期待接收 stream_count 个流\r\n        for _ in 0..stream_count {\r\n            if let Some(mut stream) = env.server_stream_rx.recv().await {\r\n                join_set.spawn(async move {\r\n                    stream.ready().await.expect(\"Server stream ready failed\");\r\n                    let mut buf = vec![0u8; 64 * 1024]; // 64KB read buffer\r\n                    let mut stream_received = 0;\r\n                    while let Ok(n) = stream.read(&mut buf).await {\r\n                        if n == 0 { break; }\r\n                        stream_received += n;\r\n                    }\r\n                    stream_received\r\n                });\r\n            } else {\r\n                error!(\"Server stream channel closed unexpectedly\");\r\n                break;\r\n            }\r\n        }\r\n\r\n        // 等待所有流接收完毕并汇总字节数\r\n        while let Some(res) = join_set.join_next().await {\r\n            total_received += res.unwrap();\r\n        }\r\n        total_received\r\n    });\r\n\r\n    // Client 端: 并发启动多个发送流\r\n    let start = Instant::now();\r\n    let mut client_set = tokio::task::JoinSet::new();\r\n    let data_chunk = Bytes::from(vec![0u8; payload_size]);\r\n\r\n    for i in 0..stream_count {\r\n        let ctrl = env.client_ctrl.clone();\r\n        let chunk = data_chunk.clone();\r\n\r\n        client_set.spawn(async move {\r\n            // 简单的连接重试逻辑（处理首个连接握手期间可能的竞争）\r\n            let mut stream = loop {\r\n                match ctrl.connect(server_addr, None, true).await {\r\n                    Ok(s) => break s,\r\n                    Err(_) => tokio::time::sleep(Duration::from_millis(10)).await,\r\n                }\r\n            };\r\n\r\n            let chunks_count = bytes_per_stream / payload_size;\r\n            let remainder = bytes_per_stream % payload_size;\r\n\r\n            for _ in 0..chunks_count {\r\n                stream.write_all(&chunk).await.expect(\"Write failed\");\r\n            }\r\n            if remainder > 0 {\r\n                stream.write_all(&chunk[..remainder]).await.expect(\"Write remainder failed\");\r\n            }\r\n            stream.shutdown().await.expect(\"Shutdown failed\");\r\n        });\r\n\r\n        // 稍微让第一个连接先跑一下，触发 QUIC 握手，避免瞬间大量 Connect 指令把 Channel 塞满导致超时\r\n        if i == 0 {\r\n            tokio::time::sleep(Duration::from_millis(50)).await;\r\n        }\r\n    }\r\n\r\n    // 等待服务端接收完所有数据（这是最准确的端到端时间）\r\n    let received_bytes = server_task.await.unwrap();\r\n    let duration = start.elapsed();\r\n\r\n    // 确保客户端任务也都干净退出了\r\n    while let Some(_) = client_set.join_next().await {}\r\n\r\n    let mb = received_bytes as f64 / 1024.0 / 1024.0;\r\n    let mb_per_sec = mb / duration.as_secs_f64();\r\n\r\n    println!(\"--------------------------------------------------\");\r\n    println!(\"测试完成:\");\r\n    println!(\"  并发流数: {}\", stream_count);\r\n    println!(\"  总传输量: {} MB\", mb as usize);\r\n    println!(\"  总耗时  : {:?}\", duration);\r\n    println!(\"  聚合带宽: {:.2} MB/s  ({:.2} Gbps)\", mb_per_sec, mb_per_sec * 8.0 / 1024.0);\r\n    println!(\"--------------------------------------------------\");\r\n}\r\n\r\n#[tokio::main(flavor = \"multi_thread\")]\r\nasync fn main() {\r\n    let filter = if cfg!(debug_assertions) {\r\n        // Debug 构建，打印所有 debug / trace\r\n        EnvFilter::new(\"qs=trace\")\r\n    } else {\r\n        // Release 构建，只打印 info 以上\r\n        EnvFilter::new(\"qs=info\")\r\n    };\r\n\r\n    // 开启日志以便观察握手过程（可选）\r\n    tracing_subscriber::fmt()\r\n        .with_env_filter(filter)\r\n        .init();\r\n\r\n    bench_aggregated_throughput(8192, 12).await;\r\n\r\n    // 1. 测带宽 (1GB 数据)\r\n    bench_throughput(1536).await;\r\n\r\n    // 给系统一点喘息时间\r\n    tokio::time::sleep(Duration::from_secs(2)).await;\r\n\r\n    // // 2. 测延迟/小包 (50,000 次 ping-pong)\r\n    // bench_pps(50_000).await;\r\n    //\r\n    // // 3. 测并发 Stream 建立 (10,000 个流)\r\n    // // 注意：如果测试 Connection，需要修改代码逻辑让 Client 看起来像不同的地址\r\n    bench_concurrency(100).await;\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main.rs b/src/main.rs
--- a/src/main.rs	(revision 0808255292ab1b61daad427bfc89e7530f95db66)
+++ b/src/main.rs	(date 1768177320583)
@@ -254,7 +254,7 @@
     let total_bytes = total_size_mb * 1024 * 1024;
     // 确保总字节数能被流数量整除，方便计算
     let bytes_per_stream = total_bytes / stream_count;
-    let payload_size = 32 * 1024; // 32KB chunks
+    let payload_size = 64 * 1024; // 32KB chunks
 
     // Server 端: 启动聚合接收任务
     // 必须将 server_stream_rx 移动进去
